<?php

/**
 * Incremental Multi-Tenant FTP Deployer
 * --------------------------------------
 * Author: Fahmi Fauzi Rahman
 *
 * Features:
 * - Incremental upload via deployment script (mtime **and hash** compare)
 * - Recursive FTP sync + cleanup
 * - Exclude/include paths from config.json
 * - Auto call patch endpoint after deployment
 * - Auto force-upload deployment script to public/ if missing
 */

/**
 * -----------------------------------------------------
 * Constants
 * -----------------------------------------------------
 */

/**
 * Deployment configuration filename.
 */
const CONFIG_FILENAME = 'config.json';

/**
 * Patch script filename.
 */
const PATCH_SCRIPT_FILENAME = 'patch-apply.php';

/**
 * Deploy list script filename.
 */
const DEPLOY_LIST_SCRIPT_FILENAME = 'deploy-list.php';

/**
 * Deploy list configuration filename.
 */
const DEPLOY_LIST_CONFIG_FILENAME = 'deploy-list-config.json';

/**
 * -----------------------------------------------------
 * Utility Functions
 * -----------------------------------------------------
 */

/**
 * Log message with timestamp.
 *
 * @param string $msg Message to display.
 * @return void
 */
function logMessage(string $msg): void
{
    echo "[" . date('H:i:s') . "] " . $msg . PHP_EOL;
}

/**
 * Ensure that a directory exists on the remote FTP server.
 * If it doesn't exist, it will be created recursively.
 *
 * @param resource $ftp Active FTP connection resource.
 * @param string $remoteDir Remote directory path to ensure.
 * @return bool True if directory exists or created successfully, false otherwise.
 */
function ftpEnsureDir($ftp, string $remoteDir): bool
{
    $parts = explode('/', trim($remoteDir, '/'));
    $path = '';
    foreach ($parts as $part) {
        if ($part === '') continue;
        $path .= '/' . $part;
        if (@ftp_chdir($ftp, $path)) continue;
        if (!@ftp_mkdir($ftp, $path)) {
            logMessage("âŒ Failed to create directory: $path");
            return false;
        }
    }
    return true;
}

/**
 * Force upload deployment script and configuration into /public directory if not found in remote.
 *
 * @param $ftp FTP connection.
 * @param string $remoteRoot Remote root directory of the project.
 * @return void
 */
function ensureDeployListExists($ftp, string $remoteRoot): void
{
    $publicDir = rtrim($remoteRoot, '/') . '/public';
    ftpEnsureDir($ftp, $publicDir);

    $localListPhp  = __DIR__ . '/' . DEPLOY_LIST_SCRIPT_FILENAME;
    $localListJson = __DIR__ . '/' . DEPLOY_LIST_CONFIG_FILENAME;

    // Pastikan dua file lokal tersedia
    foreach ([$localListPhp, $localListJson] as $localFile) {
        if (!file_exists($localFile)) {
            logMessage("âŒ Missing local file: $localFile");
            exit;
        }
    }

    // force upload deploy script
    $remoteListPhp = "$publicDir/" . DEPLOY_LIST_SCRIPT_FILENAME;
    logMessage("ğŸ“¤ Uploading fresh copy of " . DEPLOY_LIST_SCRIPT_FILENAME . "...");
    if (ftp_put($ftp, $remoteListPhp, $localListPhp, FTP_BINARY)) {
        logMessage("âœ… Uploaded " . DEPLOY_LIST_SCRIPT_FILENAME . " to /public");
    } else {
        logMessage("âš ï¸ Failed to upload " . DEPLOY_LIST_SCRIPT_FILENAME);
        exit;
    }

    // force upload config
    $remoteListJson = "$publicDir/" . DEPLOY_LIST_CONFIG_FILENAME;
    logMessage("ğŸ“¤ Uploading fresh copy of " . DEPLOY_LIST_CONFIG_FILENAME . "...");
    if (ftp_put($ftp, $remoteListJson, $localListJson, FTP_BINARY)) {
        logMessage("âœ… Uploaded " . DEPLOY_LIST_CONFIG_FILENAME);
    } else {
        logMessage("âš ï¸ Failed to upload " . DEPLOY_LIST_CONFIG_FILENAME);
        exit;
    }
}

/**
 * Fetch remote file list generated by deployment script
 * Returns associative array: [realPath => ['mtime' => ..., 'hash' => ..., 'size' => ...], ...]
 *
 * @param string $domain Domain name of target tenant.
 * @param string $token Authentication token.
 * @return array Associative array of remote file data.
 */
function fetchRemoteFileList(string $domain, string $token): array
{
    $url = "https://{$domain}/" . DEPLOY_LIST_SCRIPT_FILENAME . "?token={$token}";
    $ch = curl_init($url);
    curl_setopt_array($ch, [
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_TIMEOUT => 30,
        CURLOPT_SSL_VERIFYPEER => false,
    ]);
    $response = curl_exec($ch);
    $err = curl_error($ch);
    curl_close($ch);

    if (!$response) {
        logMessage("âš ï¸ Failed to fetch remote file list from $domain ($err)");
        return [];
    }

    $data = json_decode($response, true);
    if (!is_array($data)) {
        logMessage("âš ï¸ Invalid JSON response from " . DEPLOY_LIST_SCRIPT_FILENAME);
        return [];
    }

    logMessage("âœ… Remote file list fetched (" . count($data) . " files)");
    return $data;
}

/**
 * -----------------------------------------------------
 * Core Deployment Logic
 * -----------------------------------------------------
 */

/**
 * Perform incremental FTP synchronization between local and remote.
 * Compares local file hash and mtime against remote list to decide uploads.
 *
 * @param resource $ftp FTP connection resource.
 * @param string $projectRoot Absolute path to project root directory.
 * @param string $baseRemote Remote base path on FTP server.
 * @param array $include List of directories/files to include.
 * @param array $exclude List of paths to exclude.
 * @param array $remoteList Remote file list from deployment script from the server.
 * @return void
 */
function ftpSyncIncremental($ftp, string $projectRoot, string $baseRemote, array $include, array $exclude, array $remoteList): void
{
    $projectRoot = realpath($projectRoot) ?: $projectRoot;
    $projectRoot = rtrim(str_replace('\\', '/', $projectRoot), '/');

    foreach ($include as $path) {
        $includeReal = realpath($path);
        if (!$includeReal || !file_exists($includeReal)) {
            logMessage("âš ï¸ Skipped (not found): $path");
            continue;
        }
        $includeReal = str_replace('\\', '/', $includeReal);

        if (is_dir($includeReal)) {
            $iterator = new RecursiveIteratorIterator(
                new RecursiveDirectoryIterator($includeReal, RecursiveDirectoryIterator::SKIP_DOTS),
                RecursiveIteratorIterator::SELF_FIRST
            );

            foreach ($iterator as $file) {
                if ($file->isDir()) continue;
                $filePath = str_replace('\\', '/', $file->getPathname());

                if (strpos($filePath, $projectRoot . '/') === 0) {
                    $realPath = substr($filePath, strlen($projectRoot) + 1);
                } else {
                    $realPath = basename($filePath);
                }
                $realPath = ltrim($realPath, '/');
                if ($realPath === '') continue;

                // Exclude check
                $skip = false;
                foreach ($exclude as $ex) {
                    if (strpos($realPath, $ex) === 0) {
                        $skip = true;
                        break;
                    }
                }
                if ($skip) continue;

                $localMTime = filemtime($filePath);
                $localHash = sha1_file($filePath);
                $remoteInfo = $remoteList[$realPath] ?? null;
                $remoteMTime = $remoteInfo['mtime'] ?? null;
                $remoteHash = $remoteInfo['hash'] ?? null;

                if ($remoteHash && $remoteHash === $localHash) continue;
                if ($remoteMTime && $remoteMTime >= $localMTime) continue;

                $remotePath = rtrim($baseRemote, '/') . '/' . $realPath;
                ftpEnsureDir($ftp, dirname($remotePath));
                logMessage("[*] Uploading (hash/mtime check): $realPath");
                if (!ftp_put($ftp, $remotePath, $filePath, FTP_BINARY)) {
                    logMessage("âŒ Upload failed: $realPath");
                } else {
                    logMessage("âœ… Uploaded: $realPath");
                }
            }
        } else {
            // Single file include
            $filePath = $includeReal;
            if (strpos($filePath, $projectRoot . '/') === 0) {
                $realPath = substr($filePath, strlen($projectRoot) + 1);
            } else {
                $realPath = basename($filePath);
            }
            $realPath = ltrim($realPath, '/');

            // Exclude check
            $skip = false;
            foreach ($exclude as $ex) {
                if (strpos($realPath, $ex) === 0) {
                    $skip = true;
                    break;
                }
            }
            if ($skip) continue;

            $localMTime = filemtime($filePath);
            $localHash = sha1_file($filePath);
            $remoteInfo = $remoteList[$realPath] ?? null;
            $remoteMTime = $remoteInfo['mtime'] ?? null;
            $remoteHash = $remoteInfo['hash'] ?? null;

            if ($remoteHash && $remoteHash === $localHash) continue;
            if ($remoteMTime && $remoteMTime >= $localMTime) continue;

            $remotePath = rtrim($baseRemote, '/') . '/' . $realPath;
            ftpEnsureDir($ftp, dirname($remotePath));
            logMessage("[*] Uploading (hash/mtime check): $realPath");
            if (!ftp_put($ftp, $remotePath, $filePath, FTP_BINARY)) {
                logMessage("âŒ Upload failed: $realPath");
            } else {
                logMessage("âœ… Uploaded: $realPath");
            }
        }
    }

    // logMessage("--------------------------------------------------");
    // logMessage("ğŸ” Starting Dry-Run Cleanup Process...");

    foreach ($remoteList as $relPath => $info) {
        // 1. Tentukan path lokal berdasarkan struktur remote
        $localPath = $projectRoot . '/' . $relPath;

        // 2. Cek apakah file TIDAK ADA di lokal
        if (!file_exists($localPath)) {

            // 3. Safety Check: Cek apakah file ini masuk daftar exclude?
            // Jika masuk exclude, JANGAN dihapus (karena mungkin file sistem/logs)
            $isExcluded = false;
            foreach ($exclude as $ex) {
                if (strpos($relPath, $ex) === 0) {
                    $isExcluded = true;
                    break;
                }
            }

            if ($isExcluded) {
                logMessage("â„¹ï¸ Skipping cleanup for excluded path: $relPath");
                continue;
            }

            // 4. Proses Dry Run (Hanya Log, tidak eksekusi hapus)
            $remoteFullPath = rtrim($baseRemote, '/') . '/' . $relPath;

            // logMessage("[DRY-RUN] File not found in local. Should be deleted: $relPath");

            if (@ftp_delete($ftp, $remoteFullPath)) {
                logMessage("ğŸ—‘ï¸ Deleted: $relPath");
            } else {
                logMessage("âš ï¸ Failed to delete: $relPath (Might be a directory)");
            }
        }
    }
    logMessage("--------------------------------------------------");
}

/**
 * Call patch endpoint after deployment.
 *
 * @param string $domain Target domain.
 * @param string $token Auth token for patch script.
 * @return void
 */
function patch(string $domain, string $token): void
{
    $url = "https://{$domain}/" . PATCH_SCRIPT_FILENAME . "?token={$token}";
    $ch = curl_init($url);
    curl_setopt_array($ch, [
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_TIMEOUT => 20,
        CURLOPT_SSL_VERIFYPEER => false,
    ]);
    $response = curl_exec($ch);
    curl_close($ch);

    $data = json_decode($response);

    logMessage("ğŸ§© Patch: " . ($data->message ?: "No response"));
}

/**
 * Deploy single tenant using FTP and incremental sync.
 *
 * @param string $name Tenant name.
 * @param array $tenantCfg Tenant configuration.
 * @param array $globalCfg Global configuration.
 * @return void
 */
function deployTenant(string $name, array $tenantCfg, array $globalCfg): void
{
    logMessage("=== Deploying [$name] ===");

    $ftp = @ftp_connect($tenantCfg['host']);
    if (!$ftp) {
        logMessage("âŒ Failed to connect: {$tenantCfg['host']}");
        return;
    }

    if (!@ftp_login($ftp, $tenantCfg['user'], $tenantCfg['pass'])) {
        logMessage("âŒ Login failed for {$tenantCfg['user']}");
        ftp_close($ftp);
        return;
    }

    ftp_pasv($ftp, true);
    logMessage("ğŸ”— Connected to {$tenantCfg['host']}");

    $remoteRoot = rtrim($tenantCfg['remote_path'], '/');
    ftpEnsureDir($ftp, $remoteRoot);

    $token = $globalCfg['app_patch_token'];
    $domain = $tenantCfg['domain'];
    $includes = $globalCfg['include_path'] ?? [];
    $excludes = $globalCfg['exclude_path'] ?? [];

    // Ensure deployment script and configuration exists in remote/public
    ensureDeployListExists($ftp, $remoteRoot);

    // Fetch remote file list
    $remoteList = fetchRemoteFileList($domain, $token);

    // Perform incremental sync
    $projectRoot = realpath(__DIR__ . '/..') ?: __DIR__;
    ftpSyncIncremental($ftp, $projectRoot, $remoteRoot, $includes, $excludes, $remoteList);

    ftp_close($ftp);
    logMessage("âœ… Finished deployment for [$name]");
}

/**
 * Main entry point.
 * Loads config file, determines target tenant, and runs deployment.
 *
 * @param array $argv CLI arguments.
 * @return void
 */
function main(array $argv): void
{
    $root = __DIR__;
    $configFile = "$root/" .  CONFIG_FILENAME;

    if (!file_exists($configFile)) {
        logMessage("âŒ Missing " . CONFIG_FILENAME . " at $configFile");
        exit(1);
    }

    $cfg = json_decode(file_get_contents($configFile), true);
    if (!$cfg) {
        logMessage("âŒ Invalid " . CONFIG_FILENAME);
        exit(1);
    }

    $target = $argv[1] ?? null;
    if ($target) {
        if (!isset($cfg['tenants'][$target])) {
            logMessage("âŒ Tenant [$target] not found");
            exit(1);
        }
        $tenantCfg = $cfg['tenants'][$target];
        deployTenant($target, $tenantCfg, $cfg);
        patch($tenantCfg['domain'], $cfg['app_patch_token']);
    } else {
        foreach ($cfg['tenants'] as $name => $tenantCfg) {
            deployTenant($name, $tenantCfg, $cfg);
            patch($tenantCfg['domain'], $cfg['app_patch_token']);
        }
    }

    logMessage("ğŸ All deployments completed.");
}

// Run deployment process
main($argv);
