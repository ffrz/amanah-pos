<?php

/**
 * Incremental Multi-Tenant FTP Deployer
 * --------------------------------------
 * Author: Fahmi Fauzi Rahman
 *
 * Features:
 * - Incremental upload via deploy-list.php (mtime **and hash** compare)
 * - Recursive FTP sync + cleanup
 * - Exclude/include paths from config.json
 * - Auto call patch endpoint after deployment
 * - Auto force-upload deploy-list.php to public/ if missing
 */

/**
 * -----------------------------------------------------
 * Utility Functions
 * -----------------------------------------------------
 */

/**
 * Log message with timestamp.
 *
 * @param string $msg Message to display.
 * @return void
 */
function logMessage(string $msg): void
{
    echo "[" . date('H:i:s') . "] " . $msg . PHP_EOL;
}

/**
 * Ensure that a directory exists on the remote FTP server.
 * If it doesn't exist, it will be created recursively.
 *
 * @param resource $ftp Active FTP connection resource.
 * @param string $remoteDir Remote directory path to ensure.
 * @return bool True if directory exists or created successfully, false otherwise.
 */
function ftpEnsureDir($ftp, string $remoteDir): bool
{
    $parts = explode('/', trim($remoteDir, '/'));
    $path = '';
    foreach ($parts as $part) {
        if ($part === '') continue;
        $path .= '/' . $part;
        if (@ftp_chdir($ftp, $path)) continue;
        if (!@ftp_mkdir($ftp, $path)) {
            logMessage("âŒ Failed to create directory: $path");
            return false;
        }
    }
    return true;
}

/**
 * Force upload deploy-list.php into /public directory if not found in remote.
 *
 * @param resource $ftp FTP connection.
 * @param string $localFile Path to local deploy-list.php file.
 * @param string $remoteRoot Remote root directory of the project.
 * @return void
 */
function ensureDeployListExists($ftp, string $localFile, string $remoteRoot): void
{
    $remotePath = rtrim($remoteRoot, '/') . '/public/deploy-list.php';
    $remoteDir = dirname($remotePath);

    $list = @ftp_nlist($ftp, $remoteDir);
    $exists = false;
    if ($list) {
        foreach ($list as $file) {
            if (basename($file) === 'deploy-list.php') {
                $exists = true;
                break;
            }
        }
    }

    if (!$exists) {
        logMessage("ğŸ“¤ deploy-list.php not found in remote, uploading...");
        ftpEnsureDir($ftp, $remoteDir);
        if (!ftp_put($ftp, $remotePath, $localFile, FTP_BINARY)) {
            logMessage("âŒ Failed to upload deploy-list.php");
        } else {
            logMessage("âœ… Uploaded deploy-list.php to /public");
            sleep(3);
        }
    } else {
        logMessage("âœ… deploy-list.php already exists in remote/public");
    }
}

/**
 * Fetch remote file list generated by deploy-list.php
 * Returns associative array: [realPath => ['mtime' => ..., 'hash' => ..., 'size' => ...], ...]
 *
 * @param string $domain Domain name of target tenant.
 * @param string $token Authentication token.
 * @return array Associative array of remote file data.
 */
function fetchRemoteFileList(string $domain, string $token): array
{
    $url = "https://{$domain}/deploy-list.php?token={$token}";
    $ch = curl_init($url);
    curl_setopt_array($ch, [
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_TIMEOUT => 30,
        CURLOPT_SSL_VERIFYPEER => false,
    ]);
    $response = curl_exec($ch);
    $err = curl_error($ch);
    curl_close($ch);

    if (!$response) {
        logMessage("âš ï¸ Failed to fetch remote file list from $domain ($err)");
        return [];
    }

    $data = json_decode($response, true);
    if (!is_array($data)) {
        logMessage("âš ï¸ Invalid JSON response from deploy-list.php");
        return [];
    }

    logMessage("âœ… Remote file list fetched (" . count($data) . " files)");
    return $data;
}

/**
 * -----------------------------------------------------
 * Core Deployment Logic
 * -----------------------------------------------------
 */

/**
 * Perform incremental FTP synchronization between local and remote.
 * Compares local file hash and mtime against remote list to decide uploads.
 *
 * @param resource $ftp FTP connection resource.
 * @param string $projectRoot Absolute path to project root directory.
 * @param string $baseRemote Remote base path on FTP server.
 * @param array $include List of directories/files to include.
 * @param array $exclude List of paths to exclude.
 * @param array $remoteList Remote file list (from deploy-list.php).
 * @return void
 */
function ftpSyncIncremental($ftp, string $projectRoot, string $baseRemote, array $include, array $exclude, array $remoteList): void
{
    $projectRoot = realpath($projectRoot) ?: $projectRoot;
    $projectRoot = rtrim(str_replace('\\', '/', $projectRoot), '/');

    foreach ($include as $path) {
        $includeReal = realpath($path);
        if (!$includeReal || !file_exists($includeReal)) {
            logMessage("âš ï¸ Skipped (not found): $path");
            continue;
        }
        $includeReal = str_replace('\\', '/', $includeReal);

        if (is_dir($includeReal)) {
            $iterator = new RecursiveIteratorIterator(
                new RecursiveDirectoryIterator($includeReal, RecursiveDirectoryIterator::SKIP_DOTS),
                RecursiveIteratorIterator::SELF_FIRST
            );

            foreach ($iterator as $file) {
                if ($file->isDir()) continue;
                $filePath = str_replace('\\', '/', $file->getPathname());

                // Compute relative path (relative to project root)
                if (strpos($filePath, $projectRoot . '/') === 0) {
                    $realPath = substr($filePath, strlen($projectRoot) + 1);
                } else {
                    $realPath = basename($filePath);
                }
                $realPath = ltrim($realPath, '/');
                if ($realPath === '') continue;

                // Exclude check
                $skip = false;
                foreach ($exclude as $ex) {
                    if (strpos($realPath, $ex) === 0) {
                        $skip = true;
                        break;
                    }
                }
                if ($skip) continue;

                $localMTime = filemtime($filePath);
                $localHash = sha1_file($filePath);
                $remoteInfo = $remoteList[$realPath] ?? null;
                $remoteMTime = $remoteInfo['mtime'] ?? null;
                $remoteHash = $remoteInfo['hash'] ?? null;

                // Skip identical hash or newer remote
                if ($remoteHash && $remoteHash === $localHash) continue;
                if ($remoteMTime && $remoteMTime >= $localMTime) continue;

                // Upload file
                $remotePath = rtrim($baseRemote, '/') . '/' . $realPath;
                ftpEnsureDir($ftp, dirname($remotePath));
                logMessage("[*] Uploading (hash/mtime check): $realPath");
                if (!ftp_put($ftp, $remotePath, $filePath, FTP_BINARY)) {
                    logMessage("âŒ Upload failed: $realPath");
                } else {
                    logMessage("âœ… Uploaded: $realPath");
                }
            }
        } else {
            // Single file include
            $filePath = $includeReal;
            if (strpos($filePath, $projectRoot . '/') === 0) {
                $realPath = substr($filePath, strlen($projectRoot) + 1);
            } else {
                $realPath = basename($filePath);
            }
            $realPath = ltrim($realPath, '/');

            // Exclude check
            $skip = false;
            foreach ($exclude as $ex) {
                if (strpos($realPath, $ex) === 0) {
                    $skip = true;
                    break;
                }
            }
            if ($skip) continue;

            $localMTime = filemtime($filePath);
            $localHash = sha1_file($filePath);
            $remoteInfo = $remoteList[$realPath] ?? null;
            $remoteMTime = $remoteInfo['mtime'] ?? null;
            $remoteHash = $remoteInfo['hash'] ?? null;

            if ($remoteHash && $remoteHash === $localHash) continue;
            if ($remoteMTime && $remoteMTime >= $localMTime) continue;

            $remotePath = rtrim($baseRemote, '/') . '/' . $realPath;
            ftpEnsureDir($ftp, dirname($remotePath));
            logMessage("[*] Uploading (hash/mtime check): $realPath");
            if (!ftp_put($ftp, $remotePath, $filePath, FTP_BINARY)) {
                logMessage("âŒ Upload failed: $realPath");
            } else {
                logMessage("âœ… Uploaded: $realPath");
            }
        }
    }
}

/**
 * Call patch endpoint after deployment.
 *
 * @param string $domain Target domain.
 * @param string $token Auth token for patch-apply.php.
 * @return void
 */
function patch(string $domain, string $token): void
{
    $url = "https://{$domain}/patch-apply.php?token={$token}";
    $ch = curl_init($url);
    curl_setopt_array($ch, [
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_TIMEOUT => 20,
        CURLOPT_SSL_VERIFYPEER => false,
    ]);
    $response = curl_exec($ch);
    curl_close($ch);

    $data = json_decode($response);

    logMessage("ğŸ§© Patch: " . ($data->message ?: "No response"));
}

/**
 * Deploy single tenant using FTP and incremental sync.
 *
 * @param string $name Tenant name.
 * @param array $tenantCfg Tenant configuration.
 * @param array $globalCfg Global configuration.
 * @return void
 */
function deployTenant(string $name, array $tenantCfg, array $globalCfg): void
{
    logMessage("=== Deploying [$name] ===");

    $ftp = @ftp_connect($tenantCfg['host']);
    if (!$ftp) {
        logMessage("âŒ Failed to connect: {$tenantCfg['host']}");
        return;
    }

    if (!@ftp_login($ftp, $tenantCfg['user'], $tenantCfg['pass'])) {
        logMessage("âŒ Login failed for {$tenantCfg['user']}");
        ftp_close($ftp);
        return;
    }

    ftp_pasv($ftp, true);
    logMessage("ğŸ”— Connected to {$tenantCfg['host']}");

    $remoteRoot = rtrim($tenantCfg['remote_path'], '/');
    ftpEnsureDir($ftp, $remoteRoot);

    $token = $globalCfg['app_patch_token'];
    $domain = $tenantCfg['domain'];
    $includes = $globalCfg['include_path'] ?? [];
    $excludes = $globalCfg['exclude_path'] ?? [];

    // Ensure deploy-list.php exists in remote/public
    ensureDeployListExists($ftp, dirname(__DIR__) . '/deploy-list.php', $remoteRoot);

    // Fetch remote file list
    $remoteList = fetchRemoteFileList($domain, $token);

    // Perform incremental sync
    $projectRoot = realpath(__DIR__ . '/..') ?: __DIR__;
    ftpSyncIncremental($ftp, $projectRoot, $remoteRoot, $includes, $excludes, $remoteList);

    ftp_close($ftp);
    logMessage("âœ… Finished deployment for [$name]");
}

/**
 * Main entry point.
 * Loads config.json, determines target tenant, and runs deployment.
 *
 * @param array $argv CLI arguments.
 * @return void
 */
function main(array $argv): void
{
    $root = __DIR__;
    $configFile = "$root/config.json";

    if (!file_exists($configFile)) {
        logMessage("âŒ Missing config.json at $configFile");
        exit(1);
    }

    $cfg = json_decode(file_get_contents($configFile), true);
    if (!$cfg) {
        logMessage("âŒ Invalid config.json");
        exit(1);
    }

    $target = $argv[1] ?? null;
    if ($target) {
        if (!isset($cfg['tenants'][$target])) {
            logMessage("âŒ Tenant [$target] not found");
            exit(1);
        }
        $tenantCfg = $cfg['tenants'][$target];
        deployTenant($target, $tenantCfg, $cfg);
        patch($tenantCfg['domain'], $cfg['app_patch_token']);
    } else {
        foreach ($cfg['tenants'] as $name => $tenantCfg) {
            deployTenant($name, $tenantCfg, $cfg);
            patch($tenantCfg['domain'], $cfg['app_patch_token']);
        }
    }

    logMessage("ğŸ All deployments completed.");
}

// Run deployment process
main($argv);
